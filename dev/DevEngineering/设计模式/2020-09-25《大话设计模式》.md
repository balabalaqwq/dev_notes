## 1-7 /简单工厂模式，

### 面向对象优点

> 可维护、可扩展、可复用、灵活性好

## 2-17 策略模式*-*

定义一系列的算法，把它们一个个封装起来，并
且使它们可相互替换。本模式使得算法可独立于使用它的客户而变化。

### 2-26*-*

## 3 单一职责原则

就一个类而言，应该**仅有一个**引起它**变化**的原因。

## 4 开放—封闭原则

面对需求，对程序的改动是通过增加新代码进行的（**扩展开放**），而不是更改现有的代码（**修改关闭**）。 要 **_对变化做出抽象_** 。

## 5-41 依赖倒置原则

A.高层模块不应该依赖低层模块。两个都应该**依赖抽象**。  
B.抽象不应该依赖细节。细节应该依赖抽象。

> **_针对接口编程，不针对实现编程。_**

## 5- 42 里氏替换原则

子类可以替换父类且程序不受影响，并且子类可以扩展新的行为。

> ### 5-43 面向对象设计特征
>
> 程序中所有依赖关系都终止与抽象类或接口，那就是**面向对象设计**，反之就是**过程化设计**。

## 6-50

## 6-56 装饰模式

将每个要装饰的功能放在单独的类中并让这个类包装它所修饰的对象。

**优点**：把类中的装饰功能从类中搬移去除，简化原有类；

**特点**：装饰模式是为已有功能动态地添加更多功能的一种方式。**_原有类只放核心职责或主要行为_**。


## 7-66 代理模式

*-*P83

## 8-71 工厂方法模式

定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到其子类。

> **与简单工厂区别**： 将工厂类抽象成接口用于创建方法对象，把工厂类的逻辑判断转移到客户端。

## 9- 原型模式

**浅复制**：（引用不变）；

**深复制**：（引用新的）。

## 10-98 模板方法模式

子类中不变的行为移到父类，省去子类重复实现。（**复用**）

## 11-102*-*迪米特法则（LoD,最少知识原则）

**前提**：在类的结构设计上，每一个类都应当尽量降低成员的访问权限。

**根本思想**：强调了类之间的松耦合。（只用一个“.”，多个“.”违背此原则）

**迪米特法则（LoD)**：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。

## 12-111 外观模式（门面模式）*-*分层

**外观模式（ Facade)**：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

## 13-119 建造者模式（Builder，生成器模式）

将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

**场景**：在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。

## 14-134 观察者模式（Observer,发布-订阅（Publish/Subscribe）模式）

观察者模式定义了一种 一（**_主题/通知者_**) 对多（**_观察者_**）的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。

### 14-139 委托

委托就是一种引用方法的类型。

一旦为委托分配了方法，委托将与该方法具有完全相同的行为。委托方法的使用可以像其他任何方法一样，具有参数和返回值。委托可以看作是对函数的抽象，是函数的类',委托的实例将代表一个具体的函数。

一个委托可以搭载多个方法，所有方法被依次唤起。更重要的是，它可以使得委托对 象所搭载的方法并不需要属于同一个类。

**前提**：委托对象所搭载的所有方法必须具有相同的原形和形式，也就是 **_拥有相同的参数列表和返回值类型_**。

## 15-149 抽象工厂模式 P159

提供一个创建一系列相关 或相互依赖对象的接口，而无需指定它们具体的类。

### 15-154 反射

Assembly.Load("程序集名称") .Createlnstance("命名空间类.名称")

去除 switch 或 if，解耦。

**优化**: 使用**反射+配置文件**来解决反射更改类中变量问题。

## 16- 状态模式

当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。

状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。 **_把状态的判断逻 辑转移到表示不同状态的一系列类当中_**，可以把复杂的判断逻辑简化。（**避免修改**）

## 17-178 适配器模式*-*

适配器模式（ Adapter),将一个类的接口转换成客户希望的另外一个接口。 Adapter 模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。

类适配器模式（多重继承）和**对象适配器模式**。

## 18-186 备忘录模式*-*

**备忘录（ Memento)**:在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。

## 19-193 组合模式*-*

**组合模式（ Composite)**,将对象组合成树形结构以表示“部分-整体”的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。

## P218

## 20-207 迭代器模式*-*

**迭代器（ Iterator）模式**：就是分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合的内部结构，又可让外部代码透明地访问集合内部的数据。

## 21-216 单例模式

**单例模式（ Singleton)**：保证一个类仅有一个实例，并提供一个访问它的全局访问点。

**锁（Lock）**： lock 是确保当一个线程位于代码的临界区时，另一个线程不进入临界区。如果其他线程试图进入锁定的代码，则它将一直等待（即被阻止），直到该对象被释放。[MSDN]

**性能优化**：**_双重锁定（锁内外都判空）_** 。

**静态初始化** *-*P236

## 22-229 桥接模式（Bridge）*-*P247

将抽象部分与它的实现部分（**抽象的对象实现**）分离，是它们都可以独立的变化*-* 。

### 22-225 合成/聚合复用原则（CARP）

> **_尽量使用对象的合成/聚合，尽量不要使用类继承_**。

## 23-244 命令模式

将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

> **_只有在真正需要如撤销/恢复操作等功能时，把原来代码重构为命令模式才有意义_**。

## 24-249 职责链模式

使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

## 25-265 中介者模式（Mediator，调停者模式）

用一个中介对象来封装一系列的对象交互。中介者使得各对象不需要显示地相互引用，从而使得其耦合松散，而且可以独立的改变它们之间的交互。

**优点**： ...（中介者来集中控制各个对象）

**缺点**： 中介者过于复杂。

**场景**：中介者一般应用于一组对象以定义良好但是复杂的方式进行通讯的场合，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。

## 26-269 享元模式（Flyweight） _ - _ P290

运用共享技术有效地支持大量细粒度的对象。

**场景**：如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用；还有就是对象的大多数状态可以外部状态，如果删除对象的外部状态，那么可以用相对较少的 _共享对象_ 取代很多组对象，此时可以考虑使用享元模式。

## 27-282 解释器模式（interpreter）

给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

**例**：正则表达式、浏览器

**不足**：解释器模式为文法中的每一条规则至少定义了一个类，因此包含许多规则的文法可能难以管理和维护。

> 建议当文法非常复杂时，使用其他技术如*语法分析程序*或*编译器生成器*来处理

## 28- 访问者模式（Visitor） P309

表示一个作用于某对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。（_把处理从数据结构分离出来_）

**_访问者模式适用于数据结构相对稳定的系统_**。

**优点**：增加新的操作很容易。（_增加新的访问者_）

**缺点**：增加新的数据结构变得困难。

### 29-309 总结 P327

| 创建型     | 结构型 | 行为型   |        |
| ---------- | ------ | -------- | ------ |
| 抽象工厂   | _适配器_ | _观察者_   | 解释器 |
| 建造者     | 桥接   | 模板方法 | 中介者 |
| _工厂方法_ | 组合   | 命令     | 访问者 |
| 原型       | 装饰   | 状态     | _策略_   |
| 单例       | _外观_   | 职责链   | 备忘录 |
|            | 享元   |          | 迭代器 |
| /简单工厂   | 代理   |          |        |

**_高内聚，低耦合_**：

*内聚性*描述的是一个例程内部组成部分之间相互联系的紧密程度。

*耦合性*描述的是一个例程与其它例程之间联系的紧密程度。

> 软件开发的目标应该是创建这样的例程：
> **_内部完整，也就是高内聚，而与其它例程之间的联系则是小巧、直接、可见、灵活的，这就是松耦合。_**

**_创建型模式_**： 创建型模式隐藏了这些类的实例是如何被创建和放在一起，整个系统关于这些对象所知道的是由抽象类所定义的接口。这样，创建型模式在创建了什么、谁创建它、它是怎么被创建的，以及何时创建这些方面提供了很大的灵活性。



#### 335 附录 P353

